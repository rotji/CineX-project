// Stacks blockchain integration for transaction handling
// Handles actual transaction submission and monitoring with CineX contracts

import { 
  openContractCall,
  showConnect
} from '@stacks/connect';
import { 
  PostConditionMode,
  FungibleConditionCode,
  standardPrincipalCV,
  uintCV,
  stringAsciiCV,
  bufferCV,
  listCV,
  tupleCV
} from '@stacks/transactions';
import { 
  transactionTracker
} from './transactionTracker';
import type {
  TransactionConfig,
  TransactionType,
  TransactionError 
} from './transactionTracker';
import { getNetworkConfig } from './contracts';

/**
 * Stacks transaction integration options
 */
export interface StacksTxOptions {
  contractAddress: string;
  contractName: string;
  functionName: string;
  functionArgs: any[];
  amount?: string;
  recipient?: string;
  postConditions?: any[];
  network?: StacksNetwork;
  userSession?: UserSession;
  onSuccess?: (data: FinishedTxData) => void;
  onCancel?: () => void;
}

/**
 * Campaign creation transaction parameters
 */
export interface CampaignCreateParams {
  title: string;
  description: string;
  targetAmount: number;
  duration: number;
  category: string;
  mediaHashes: string[];
}

/**
 * Pool creation transaction parameters
 */
export interface PoolCreateParams {
  name: string;
  description: string;
  bondAmount: number;
  maxMembers: number;
  duration: number;
}

/**
 * Stacks transaction handler class
 */
class StacksTransactionHandler {
  private userSession: UserSession | null = null;
  
  constructor() {
    // Initialize user session if needed
    this.initializeUserSession();
  }
  
  /**
   * Initialize user session for Stacks authentication
   */
  private initializeUserSession(): void {
    try {
      const appConfig = {
        appDomain: window.location.origin,
        scopes: ['store_write', 'publish_data']
      };
      // UserSession initialization would go here when needed
    } catch (error) {
      console.warn('Could not initialize user session:', error);
    }
  }
  
  /**
   * Check if user is authenticated
   */
  isAuthenticated(): boolean {
    return this.userSession?.isUserSignedIn() ?? false;
  }
  
  /**
   * Connect wallet
   */
  async connectWallet(): Promise<void> {
    return new Promise((resolve, reject) => {
      showConnect({
        appDetails: {
          name: 'CineX Platform',
          icon: `${window.location.origin}/favicon.ico`
        },
        onFinish: () => {
          resolve();
        },
        onCancel: () => {
          reject(new Error('User cancelled wallet connection'));
        }
      });
    });
  }
  
  /**
   * Create a new campaign
   */
  async createCampaign(
    params: CampaignCreateParams,
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const functionArgs = [
      stringAsciiCV(params.title),
      stringAsciiCV(params.description),
      uintCV(params.targetAmount),
      uintCV(params.duration),
      stringAsciiCV(params.category),
      listCV(params.mediaHashes.map(hash => bufferCV(Buffer.from(hash, 'hex'))))
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.crowdfunding.address,
      contractName: config.contracts.crowdfunding.name,
      functionName: 'create-campaign',
      functionArgs,
      network: config.network,
      postConditionMode: PostConditionMode.Allow,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Contribute to a campaign
   */
  async contributeToCampaign(
    campaignId: number,
    amount: number,
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const functionArgs = [
      uintCV(campaignId),
      uintCV(amount)
    ];
    
    // Create post condition for STX transfer
    const userAddress = this.getUserAddress();
    if (!userAddress) {
      throw new Error('User not authenticated');
    }
    
    const postConditions = [
      makeStandardSTXPostCondition(
        userAddress,
        FungibleConditionCode.Equal,
        amount
      )
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.crowdfunding.address,
      contractName: config.contracts.crowdfunding.name,
      functionName: 'contribute-to-campaign',
      functionArgs,
      network: config.network,
      postConditions,
      postConditionMode: PostConditionMode.Deny,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Create a new Co-EP pool
   */
  async createPool(
    params: PoolCreateParams,
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const functionArgs = [
      stringAsciiCV(params.name),
      stringAsciiCV(params.description),
      uintCV(params.bondAmount),
      uintCV(params.maxMembers),
      uintCV(params.duration)
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.coEP.address,
      contractName: config.contracts.coEP.name,
      functionName: 'create-pool',
      functionArgs,
      network: config.network,
      postConditionMode: PostConditionMode.Allow,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Join an existing Co-EP pool
   */
  async joinPool(
    poolId: number,
    bondAmount: number,
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const functionArgs = [
      uintCV(poolId),
      uintCV(bondAmount)
    ];
    
    // Create post condition for bond payment
    const userAddress = this.getUserAddress();
    if (!userAddress) {
      throw new Error('User not authenticated');
    }
    
    const postConditions = [
      makeStandardSTXPostCondition(
        userAddress,
        FungibleConditionCode.Equal,
        bondAmount
      )
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.coEP.address,
      contractName: config.contracts.coEP.name,
      functionName: 'join-pool',
      functionArgs,
      network: config.network,
      postConditions,
      postConditionMode: PostConditionMode.Deny,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Deposit funds into escrow
   */
  async depositToEscrow(
    amount: number,
    recipient: string,
    conditions: string,
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const functionArgs = [
      uintCV(amount),
      standardPrincipalCV(recipient),
      stringAsciiCV(conditions)
    ];
    
    // Create post condition for escrow deposit
    const userAddress = this.getUserAddress();
    if (!userAddress) {
      throw new Error('User not authenticated');
    }
    
    const postConditions = [
      makeStandardSTXPostCondition(
        userAddress,
        FungibleConditionCode.Equal,
        amount
      )
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.escrow.address,
      contractName: config.contracts.escrow.name,
      functionName: 'create-escrow',
      functionArgs,
      network: config.network,
      postConditions,
      postConditionMode: PostConditionMode.Deny,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Submit film for verification
   */
  async submitVerification(
    filmHash: string,
    metadata: { [key: string]: string },
    transactionId: string
  ): Promise<void> {
    const config = await getNetworkConfig();
    
    const metadataTuple = tupleCV(
      Object.entries(metadata).reduce((acc, [key, value]) => {
        acc[key] = stringAsciiCV(value);
        return acc;
      }, {} as { [key: string]: any })
    );
    
    const functionArgs = [
      bufferCV(Buffer.from(filmHash, 'hex')),
      metadataTuple
    ];
    
    const contractCallOptions: ContractCallOptions = {
      contractAddress: config.contracts.verification.address,
      contractName: config.contracts.verification.name,
      functionName: 'submit-for-verification',
      functionArgs,
      network: config.network,
      postConditionMode: PostConditionMode.Allow,
      onFinish: (data: FinishedTxData) => {
        this.handleTransactionSuccess(transactionId, data);
      },
      onCancel: () => {
        this.handleTransactionCancel(transactionId);
      }
    };
    
    try {
      transactionTracker.updateTransactionStatus(transactionId, 'pending');
      await openContractCall(contractCallOptions);
    } catch (error) {
      this.handleTransactionError(transactionId, error as Error);
    }
  }
  
  /**
   * Get user's Stacks address
   */
  private getUserAddress(): string | null {
    return this.userSession?.loadUserData?.()?.profile?.stxAddress?.testnet || null;
  }
  
  /**
   * Handle successful transaction
   */
  private handleTransactionSuccess(transactionId: string, data: FinishedTxData): void {
    transactionTracker.updateTransactionStatus(
      transactionId,
      'broadcasting',
      undefined,
      data.txId
    );
    
    // Start monitoring transaction
    this.monitorTransaction(transactionId, data.txId);
  }
  
  /**
   * Handle cancelled transaction
   */
  private handleTransactionCancel(transactionId: string): void {
    transactionTracker.updateTransactionStatus(transactionId, 'cancelled');
  }
  
  /**
   * Handle transaction error
   */
  private handleTransactionError(transactionId: string, error: Error): void {
    const transactionError: TransactionError = {
      code: 'TRANSACTION_ERROR',
      message: error.message,
      userMessage: 'Failed to submit transaction. Please try again.',
      isRetryable: true,
      details: error
    };
    
    transactionTracker.updateTransactionStatus(transactionId, 'failed', transactionError);
  }
  
  /**
   * Monitor transaction status on blockchain
   */
  private async monitorTransaction(transactionId: string, txId: string): Promise<void> {
    const config = await getNetworkConfig();
    const maxAttempts = 60; // 5 minutes with 5-second intervals
    let attempts = 0;
    
    const checkStatus = async (): Promise<void> => {
      try {
        attempts++;
        
        // In a real implementation, you would call the Stacks API to check transaction status
        // For now, we'll simulate the monitoring process
        const response = await fetch(`${config.network.coreApiUrl}/extended/v1/tx/${txId}`);
        
        if (response.ok) {
          const txData = await response.json();
          
          switch (txData.tx_status) {
            case 'pending':
              transactionTracker.updateTransactionStatus(transactionId, 'submitted');
              break;
            case 'success':
              transactionTracker.updateTransactionStatus(transactionId, 'success');
              return; // Stop monitoring
            case 'abort_by_response':
            case 'abort_by_post_condition':
              const error: TransactionError = {
                code: 'TRANSACTION_ABORTED',
                message: txData.tx_result?.repr || 'Transaction was aborted',
                userMessage: 'Transaction failed. Please check your inputs and try again.',
                isRetryable: true
              };
              transactionTracker.updateTransactionStatus(transactionId, 'failed', error);
              return; // Stop monitoring
          }
        }
        
        // Continue monitoring if transaction is still pending and we haven't exceeded max attempts
        if (attempts < maxAttempts) {
          setTimeout(checkStatus, 5000); // Check again in 5 seconds
        } else {
          // Timeout
          const timeoutError: TransactionError = {
            code: 'MONITORING_TIMEOUT',
            message: 'Transaction monitoring timed out',
            userMessage: 'Transaction is taking longer than expected. Please check the explorer.',
            isRetryable: false
          };
          transactionTracker.updateTransactionStatus(transactionId, 'timeout', timeoutError);
        }
      } catch (error) {
        console.error('Error monitoring transaction:', error);
        
        // Continue monitoring despite API errors (could be temporary)
        if (attempts < maxAttempts) {
          setTimeout(checkStatus, 10000); // Wait longer on error
        }
      }
    };
    
    // Start monitoring after a brief delay
    setTimeout(checkStatus, 2000);
  }
}

// Export singleton instance
export const stacksHandler = new StacksTransactionHandler();

/**
 * High-level transaction functions for easy use in components
 */
export const StacksTransactions = {
  /**
   * Create a campaign with transaction tracking
   */
  async createCampaign(params: CampaignCreateParams): Promise<string> {
    const config: TransactionConfig = {
      type: 'campaign-create' as TransactionType,
      title: 'Create Campaign',
      description: `Creating campaign: ${params.title}`,
      maxRetries: 3,
      timeout: 300000 // 5 minutes
    };
    
    const transactionId = transactionTracker.createTransaction(config);
    
    try {
      await stacksHandler.createCampaign(params, transactionId);
      return transactionId;
    } catch (error) {
      stacksHandler['handleTransactionError'](transactionId, error as Error);
      throw error;
    }
  },
  
  /**
   * Contribute to a campaign with transaction tracking
   */
  async contributeToCampaign(campaignId: number, amount: number): Promise<string> {
    const config: TransactionConfig = {
      type: 'campaign-contribute' as TransactionType,
      title: 'Contribute to Campaign',
      description: `Contributing ${amount} μSTX to campaign #${campaignId}`,
      amount: amount.toString(),
      maxRetries: 3,
      timeout: 300000
    };
    
    const transactionId = transactionTracker.createTransaction(config);
    
    try {
      await stacksHandler.contributeToCampaign(campaignId, amount, transactionId);
      return transactionId;
    } catch (error) {
      stacksHandler['handleTransactionError'](transactionId, error as Error);
      throw error;
    }
  },
  
  /**
   * Create a Co-EP pool with transaction tracking
   */
  async createPool(params: PoolCreateParams): Promise<string> {
    const config: TransactionConfig = {
      type: 'pool-create' as TransactionType,
      title: 'Create Pool',
      description: `Creating pool: ${params.name}`,
      maxRetries: 3,
      timeout: 300000
    };
    
    const transactionId = transactionTracker.createTransaction(config);
    
    try {
      await stacksHandler.createPool(params, transactionId);
      return transactionId;
    } catch (error) {
      stacksHandler['handleTransactionError'](transactionId, error as Error);
      throw error;
    }
  },
  
  /**
   * Join a Co-EP pool with transaction tracking
   */
  async joinPool(poolId: number, bondAmount: number): Promise<string> {
    const config: TransactionConfig = {
      type: 'pool-join' as TransactionType,
      title: 'Join Pool',
      description: `Joining pool #${poolId} with ${bondAmount} μSTX bond`,
      amount: bondAmount.toString(),
      maxRetries: 3,
      timeout: 300000
    };
    
    const transactionId = transactionTracker.createTransaction(config);
    
    try {
      await stacksHandler.joinPool(poolId, bondAmount, transactionId);
      return transactionId;
    } catch (error) {
      stacksHandler['handleTransactionError'](transactionId, error as Error);
      throw error;
    }
  }
};

/**
 * Hook for Stacks wallet connection
 */
export function useStacksWallet() {
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  
  const connect = async () => {
    setIsConnecting(true);
    try {
      await stacksHandler.connectWallet();
      setIsConnected(true);
      setAddress(stacksHandler['getUserAddress']());
    } catch (error) {
      console.error('Failed to connect wallet:', error);
      throw error;
    } finally {
      setIsConnecting(false);
    }
  };
  
  const disconnect = () => {
    // In a real implementation, you would sign out the user
    setIsConnected(false);
    setAddress(null);
  };
  
  return {
    isConnected,
    isConnecting,
    address,
    connect,
    disconnect
  };
}